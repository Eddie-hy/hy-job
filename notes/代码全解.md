###  一、配置运行模块

1.把需要的属性在properties文件中统一标注好

```properties
# web port
server.port=9998
# no web
#spring.main.web-environment=false

# log config
logging.config=classpath:logback.xml


### xxl-job admin address list, such as "http://address" or "http://address01,http://address02"
xxl.job.admin.addresses=http://127.0.0.1:9090/hy-job-admin

### xxl-job, access token
xxl.job.accessToken=default_token

### xxl-job executor appname
xxl.job.executor.appname=hy-job-executor-sample
### xxl-job executor registry-address: default use address to registry , otherwise use ip:port if address is null
xxl.job.executor.address=
### xxl-job executor server-info
xxl.job.executor.ip=
xxl.job.executor.port=9999
### xxl-job executor log-path
xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler
### xxl-job executor log-retention-days
xxl.job.executor.logretentiondays=30
```



2.通过config文件把配置文件中的参数导入到Spring bean中在放到Spring容器中

```java
package com.hy.job.executor.core.config;

import com.hy.job.core.executor.impl.XxlJobSpringExecutor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Author: HY
 * @Date: 2023-10-26-21:18
 * @Description:配置类
 */
@Configuration    //加上配置注解，使得启动时可以当作配置类来扫描
public class HyConfig {

    private Logger logger = LoggerFactory.getLogger(HyConfig.class);

    @Value("${xxl.job.admin.addresses}")
    private String adminAddresses;

    @Value("${xxl.job.accessToken}")
    private String accessToken;

    @Value("${xxl.job.executor.appname}")
    private String appname;

    @Value("${xxl.job.executor.address}")
    private String address;

    @Value("${xxl.job.executor.ip}")
    private String ip;

    @Value("${xxl.job.executor.port}")
    private int port;

    @Value("${xxl.job.executor.logpath}")
    private String logPath;

    @Value("${xxl.job.executor.logretentiondays}")
    private int logRetentionDays;

    @Bean   //放在spring bean容器中 可以直接注入
    public XxlJobSpringExecutor hyJobExecutor() {
        logger.info(">>>>>>>>>>> xxl-job config init.");
        XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();
        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);
        xxlJobSpringExecutor.setAppname(appname);
        xxlJobSpringExecutor.setAddress(address);
        xxlJobSpringExecutor.setIp(ip);
        xxlJobSpringExecutor.setPort(port);
        xxlJobSpringExecutor.setAccessToken(accessToken);
        xxlJobSpringExecutor.setLogPath(logPath);
        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);

        return xxlJobSpringExecutor;
    }
    /**
     * 针对多网卡、容器内部署等情况，可借助 "spring-cloud-commons" 提供的 "InetUtils" 组件灵活定制注册IP；
     *
     *      1、引入依赖：
     *          <dependency>
     *             <groupId>org.springframework.cloud</groupId>
     *             <artifactId>spring-cloud-commons</artifactId>
     *             <version>${version}</version>
     *         </dependency>
     *
     *      2、配置文件，或者容器启动变量
     *          spring.cloud.inetutils.preferred-networks: 'xxx.xxx.xxx.'
     *
     *      3、获取IP
     *          String ip_ = inetUtils.findFirstNonLoopbackHostInfo().getIpAddress();
     */
}

```



3.创建运行实例,通过自定义注解xxljob把方法注入到容器中以供查找，需要在前端注册相应的执行器存进数据库中

```java
package com.hy.job.executor.service.jobhandler;

import com.hy.job.core.handler.annotation.XxlJob;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.Date;

/**
 * @Author: HY
 * @Date: 2023-10-26-21:22
 * @Description:
 */
@Component    //放入IOC容器中
public class SampleHyJob {


    private static Logger logger = LoggerFactory.getLogger(SampleHyJob.class);

    @XxlJob("test01")
    public void testApp1(){
        logger.info("我是你爹一号执行成功！执行时间是："+new Date());
        System.out.println("请别乱认爹！");
    }
}

```



4.注册

- 执行器注册
  - 在执行器端注册执行器所运行的端口号，然后注册执行器·唯一id,一般注册方式为手动注册
- 任务表注册
  - 注册时如果为bean模式，需要在**JobHandler**写入xxljob注解命名的名字
  - 如果是glue模式，需要自己在网页ide中书写代码，然后根据不同脚本调用不同的编译器执行





###  二、启动总配置

##### 1.任务执行一次流程

- 前端发送请求trigger触发线程池的任务调用，任务参数如下，id为任务id，执行参数为null,地址如果为空会调用数据库默认保存到地址

![image-20231028151735331](../图片/image-20231028151735331.png)

- 调用线程触发器的触发函数

```java
JobTriggerPoolHelper.trigger(id, TriggerTypeEnum.MANUAL, -1, null, executorParam, addressList);
//任务id  触发模式（手动） 重新尝试次数               执行参数  地址
```

- 设置快慢线程池，默认使用快线程池，当请求在一分钟内超时处理（500毫秒）十次之后，会转用慢线程池。快慢线程池的区别就是线程数量和队列容量不同，快线程池的线程数量多而且队列容量小，慢线程池反之，这样做是为了让任务分配到适合的线程池中，以达到更好的性能和任务处理效率

```java
/**
     * 根据触发器判断使用快线程池还是慢线程池
     */
    public void addTrigger(final int jobId,
                           final TriggerTypeEnum triggerType,
                           final int failRetryCount,
                           final String executorShardingParam,
                           final String executorParam,
                           final String addressList) {

        //默认使用快线程池，如果超时十次，就使用慢线程池
        ThreadPoolExecutor triggerPool = fastTriggerPool;
        AtomicInteger jobTimeoutCount = jobTimeoutCountMap.get(jobId);
        if(jobTimeoutCount != null && jobTimeoutCount.get() > 10){    //一个任务一分钟超时十次换到慢线程池
            triggerPool = slowTriggerPool;
        }

        //执行
        triggerPool.execute(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();

                try {
                    //使用触发器
                    XxlJobTrigger.trigger(jobId, triggerType, failRetryCount, executorShardingParam, executorParam, addressList);
                }catch (Exception e){
                    logger.error(e.getMessage(), e);
                }finally {
                    //检查任务时间超时
                    long minTim_now = System.currentTimeMillis()/60000;
                    if(minTim != minTim_now){
                        minTim = minTim_now;
                        jobTimeoutCountMap.clear();
                    }

                    //增加超时计数映射
                    long cost  = System.currentTimeMillis()-start;
                    if(cost > 500){    //超时阈值 500 毫秒
                        AtomicInteger timeoutCount = jobTimeoutCountMap.putIfAbsent(jobId,new AtomicInteger(1));
                        //如果之前这种任务超时就存在,增加1
                        if(timeoutCount != null){
                            timeoutCount.incrementAndGet();
                        }
                    }

                }

            }
        });
    }
```

- 因为前端发送来的参数不多，所以需要根据任务id绑定任务，还需要根据任务绑定的执行器提取执行器信息，在这之后会根据是否采用分片策略去判断是否需要广播地址，调用多个地址去执行这同一个任务，如果不是就老实调用一个地址去执行，还会判断执行参数是否为空

```java
public static void trigger(int jobId,
                               TriggerTypeEnum triggerType,
                               int failRetryCount,
                               String executorShardingParam,
                               String executorParam,
                               String addressList) {

        //加载任务数据
        XxlJobInfo jobInfo = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().loadById(jobId);
        if(jobInfo == null){
            logger.warn(">>>>>>>>>>>> trigger fail, jobId invalid，jobId={}", jobId);
            return;
        }
        if(executorParam != null){
            jobInfo.setExecutorParam(executorParam);
        }
        int finalFailRetryCount = failRetryCount>=0?failRetryCount:jobInfo.getExecutorFailRetryCount();
        //导入执行器
        XxlJobGroup group  = XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().load(jobInfo.getJobGroup());

        //分割执行参数
        int[] shardingParam = null;
        if(executorShardingParam != null){
            String[] shardingArr = executorShardingParam.split("/");
            if(shardingArr.length == 2 && isNumeric(shardingArr[0]) && isNumeric(shardingArr[1])){
             shardingParam = new int[2];
             shardingParam[0] = Integer.valueOf(shardingArr[0]);
             shardingParam[1] = Integer.valueOf(shardingArr[1]);
            }
        }
        if (ExecutorRouteStrategyEnum.SHARDING_BROADCAST==ExecutorRouteStrategyEnum.match(jobInfo.getExecutorRouteStrategy(), null)
                && group.getRegistryList()!=null && !group.getRegistryList().isEmpty()
                && shardingParam==null) {
            for(int i = 0;i < group.getRegistryList().size(); i++){
                processTrigger(group, jobInfo, finalFailRetryCount, triggerType, i, group.getRegistryList().size());
            }
        } else {
            if(shardingParam == null){
                shardingParam = new int[]{0,1};
            }
            processTrigger(group, jobInfo, finalFailRetryCount, triggerType, shardingParam[0], shardingParam[1]);
        }


    }
```

- 根据不同的路由协议选择不同的地址，然后执行，执行后无论成功失败，保存日志信息

```java
private static void processTrigger(XxlJobGroup group, XxlJobInfo jobInfo, int finalFailRetryCount, TriggerTypeEnum triggerType, int index, int total){

        //参数
        //阻塞策略
        ExecutorBlockStrategyEnum blockStrategy = ExecutorBlockStrategyEnum.match(jobInfo.getExecutorBlockStrategy(), ExecutorBlockStrategyEnum.SERIAL_EXECUTION);
        //路由策略
        ExecutorRouteStrategyEnum executorRouteStrategyEnum = ExecutorRouteStrategyEnum.match(jobInfo.getExecutorRouteStrategy(), null);
        //执行参数改格式
        String shardingParam = (ExecutorRouteStrategyEnum.SHARDING_BROADCAST == executorRouteStrategyEnum)?String.valueOf(index).concat("/").concat(String.valueOf(total)):null;

        //保存日志文件参数
        XxlJobLog jobLog = new XxlJobLog();
        jobLog.setJobGroup(jobInfo.getJobGroup());
        jobLog.setJobId(jobInfo.getId());
        jobLog.setTriggerTime(new Date());
        XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().save(jobLog);
        logger.debug(">>>>>>>>>>> xxl-job trigger start, jobId:{}", jobLog.getId());

        //初始化触发参数
        TriggerParam triggerParam = new TriggerParam();
        triggerParam.setJobId(jobInfo.getId());
        triggerParam.setExecutorHandler(jobInfo.getExecutorHandler());
        triggerParam.setExecutorParams(jobInfo.getExecutorParam());
        triggerParam.setExecutorBlockStrategy(jobInfo.getExecutorBlockStrategy());
        triggerParam.setExecutorTimeout(jobInfo.getExecutorTimeout());
        triggerParam.setLogId(jobLog.getId());
        triggerParam.setLogDateTime(jobLog.getTriggerTime().getTime());
        triggerParam.setGlueType(jobInfo.getGlueType());
        triggerParam.setGlueSource(jobInfo.getGlueSource());
        triggerParam.setGlueUpdatetime(jobInfo.getGlueUpdatetime().getTime());
        triggerParam.setBroadcastIndex(index);
        triggerParam.setBroadcastTotal(total);

        //初始化地址
        String address = null;
        ReturnT<String> routeAddressResult = null;
        if(group.getRegistryList() != null && !group.getRegistryList().isEmpty()){
            if(ExecutorRouteStrategyEnum.SHARDING_BROADCAST == executorRouteStrategyEnum){
                if(index < group.getRegistryList().size()){
                    address = group.getRegistryList().get(index);
                }else{
                    address = group.getRegistryList().get(0);
                }
            }else{
                //根据路由策略得到地址
                routeAddressResult = executorRouteStrategyEnum.getRouter().route(triggerParam,group.getRegistryList());
                if(routeAddressResult.getCode() == ReturnT.SUCCESS_CODE){
                    address = routeAddressResult.getContent();
                }
            }
        }else {
            routeAddressResult = new ReturnT<String>(ReturnT.FAIL_CODE, I18nUtil.getString("jobconf_trigger_address_empty"));
        }

        //触发执行器
        ReturnT<String> triggerResult = null;
        if(address != null){
            triggerResult = runExecutor(triggerParam,address);
        }else{
            triggerResult = new ReturnT<String>(ReturnT.FAIL_CODE,null);
        }

        //收集触发信息
        StringBuffer triggerMsgSb = new StringBuffer();
        triggerMsgSb.append(I18nUtil.getString("jobconf_trigger_type")).append("：").append(triggerType.getTitle());
        triggerMsgSb.append("<br>").append(I18nUtil.getString("jobconf_trigger_admin_adress")).append("：").append(IpUtil.getIp());
        triggerMsgSb.append("<br>").append(I18nUtil.getString("jobconf_trigger_exe_regtype")).append("：")
                .append( (group.getAddressType() == 0)?I18nUtil.getString("jobgroup_field_addressType_0"):I18nUtil.getString("jobgroup_field_addressType_1") );
        triggerMsgSb.append("<br>").append(I18nUtil.getString("jobconf_trigger_exe_regaddress")).append("：").append(group.getRegistryList());
        triggerMsgSb.append("<br>").append(I18nUtil.getString("jobinfo_field_executorRouteStrategy")).append("：").append(executorRouteStrategyEnum.getTitle());
        if (shardingParam != null) {
            triggerMsgSb.append("("+shardingParam+")");
        }
        triggerMsgSb.append("<br>").append(I18nUtil.getString("jobinfo_field_executorBlockStrategy")).append("：").append(blockStrategy.getTitle());
        triggerMsgSb.append("<br>").append(I18nUtil.getString("jobinfo_field_timeout")).append("：").append(jobInfo.getExecutorTimeout());
        triggerMsgSb.append("<br>").append(I18nUtil.getString("jobinfo_field_executorFailRetryCount")).append("：").append(finalFailRetryCount);

        triggerMsgSb.append("<br><br><span style=\"color:#00c0ef;\" > >>>>>>>>>>>"+ I18nUtil.getString("jobconf_trigger_run") +"<<<<<<<<<<< </span><br>")
                .append((routeAddressResult!=null&&routeAddressResult.getMsg()!=null)?routeAddressResult.getMsg()+"<br><br>":"").append(triggerResult.getMsg()!=null?triggerResult.getMsg():"");

        //保存日志信息
        jobLog.setExecutorAddress(address);
        jobLog.setExecutorHandler(jobInfo.getExecutorHandler());
        jobLog.setExecutorParam(jobInfo.getExecutorParam());
        jobLog.setExecutorShardingParam(shardingParam);
        jobLog.setExecutorFailRetryCount(finalFailRetryCount);
        //jobLog.setTriggerTime();
        jobLog.setTriggerCode(triggerResult.getCode());
        jobLog.setTriggerMsg(triggerMsgSb.toString());
        XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateTriggerInfo(jobLog);

        logger.debug(">>>>>>>>>>> xxl-job trigger end, jobId:{}", jobLog.getId());
    }
```

- 从缓存中加载执行器信息，避免重新创建实例对象,然后调用执行器的run函数

```java
public static ReturnT<String> runExecutor(TriggerParam triggerParam, String address){
        ReturnT<String> runResult = null;
        try {
            ExecutorBiz executorBiz = XxlJobScheduler.getExecutorBiz(address);
            runResult = executorBiz.run(triggerParam);
        }catch (Exception e){
            logger.error(">>>>>>>>>>> xxl-job trigger error, please check if the executor[{}] is running.", address, e);
            runResult = new ReturnT<String>(ReturnT.FAIL_CODE, ThrowableUtil.toString(e));
        }
        StringBuffer runResultSB = new StringBuffer(I18nUtil.getString("jobconf_trigger_run") + "：");
        runResultSB.append("<br>address：").append(address);
        runResultSB.append("<br>code：").append(runResult.getCode());
        runResultSB.append("<br>msg：").append(runResult.getMsg());

        runResult.setMsg(runResultSB.toString());
        return runResult;
    }
```

- run函数其实就是调用postBody函数发送请求

```java
 @Override
    public ReturnT<String> run(TriggerParam triggerParam) {
        return XxlJobRemotingUtil.postBody(addressUrl + "run", accessToken, timeout, triggerParam, String.class);
    }
```

- 调用postBody函数发送请求,首先会执行https连接,然后把触发参数转发为json格式发送到指定地址

```java
public static ReturnT postBody(String url, String accessToken, int timeout, Object requestObj, Class returnTargClassOfT) {

        //创建url对象
        HttpURLConnection connection = null;
        BufferedReader bufferedReader = null;

        try {
            //建立连接
            URL realUrl = new URL(url);
            connection = (HttpURLConnection) realUrl.openConnection();

            //信任https链接
            boolean useHttps = url.startsWith("https");
            if(useHttps){
                HttpsURLConnection https = (HttpsURLConnection) connection;
                trustAllHosts(https);
            }

            //链接限制设置
            connection.setRequestMethod("POST");
            connection.setDoOutput(true);
            connection.setDoInput(true);
            connection.setUseCaches(false);
            connection.setReadTimeout(timeout * 1000);
            connection.setConnectTimeout(3 * 1000);
            connection.setRequestProperty("connection", "Keep-Alive");
            connection.setRequestProperty("Content-Type", "application/json;charset=UTF-8");
            connection.setRequestProperty("Accept-Charset", "application/json;charset=UTF-8");

            if(accessToken != null && accessToken.trim().length() > 0){
                connection.setRequestProperty(XXL_JOB_ACCESS_TOKEN, accessToken);
            }

            //执行连接
            connection.connect();

            //把请求体写入参数
            if(requestObj != null){
                String requestBody = GsonTool.toJson(requestObj);

                //把数据写入https请求中
                DataOutputStream dataOutputStream = new DataOutputStream(connection.getOutputStream());
                dataOutputStream.write(requestBody.getBytes("UTF-8"));
                dataOutputStream.flush();
                dataOutputStream.close();
            }

            //判断状态是否有效
            int statusCode = connection.getResponseCode();
            if(statusCode != 200){
                return new ReturnT<String>(ReturnT.FAIL_CODE, "xxl-job remoting fail, StatusCode("+ statusCode +") invalid. for url : " + url);
            }

            //结果
            bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
            StringBuilder result = new StringBuilder();
            String line;
            while ((line = bufferedReader.readLine()) != null) {
                result.append(line);
            }
            String resultJson = result.toString();

            //转换返回结果的格式
            try {
                ReturnT returnT = GsonTool.fromJson(resultJson, ReturnT.class, returnTargClassOfT);
                return returnT;
            } catch (Exception e) {
                logger.error("xxl-job remoting (url="+url+") response content invalid("+ resultJson +").", e);
                return new ReturnT<String>(ReturnT.FAIL_CODE, "xxl-job remoting (url="+url+") response content invalid("+ resultJson +").");
            }

        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return new ReturnT<String>(ReturnT.FAIL_CODE, "xxl-job remoting error("+ e.getMessage() +"), for url : " + url);
        }finally {
            //收尾工作
            try {
                if (bufferedReader != null) {
                    bufferedReader.close();
                }
                if (connection != null) {
                    connection.disconnect();
                }
            } catch (Exception e2) {
                logger.error(e2.getMessage(), e2);
            }
        }
    }
```

- 开启netty服务器，每个netty线程会绑定一个端口为执行器，然后接收发送到端口请求并执行

```java
private Object process(HttpMethod httpMethod, String uri, String requestData, String accessTokenReq){

            //判断参数是否有效
            if (HttpMethod.POST != httpMethod) {
                return new ReturnT<String>(ReturnT.FAIL_CODE, "invalid request, HttpMethod not support.");
            }
            if (uri == null || uri.trim().length() == 0) {
                return new ReturnT<String>(ReturnT.FAIL_CODE, "invalid request, uri-mapping empty.");
            }
            if (accessToken != null
                    && accessToken.trim().length() > 0
                    && !accessToken.equals(accessTokenReq)) {
                return new ReturnT<String>(ReturnT.FAIL_CODE, "The access token is wrong.");
            }

            //服务匹配
            try {
                switch (uri) {
                    case "/beat":
                        return executorBiz.beat();
                    case "/idleBeat":
                        IdleBeatParam idleBeatParam = GsonTool.fromJson(requestData, IdleBeatParam.class);
                        return executorBiz.idleBeat(idleBeatParam);
                    case "/run":
                        TriggerParam triggerParam = GsonTool.fromJson(requestData, TriggerParam.class);
                        return executorBiz.run(triggerParam);
                    case "/kill":
                        KillParam killParam = GsonTool.fromJson(requestData, KillParam.class);
                        return executorBiz.kill(killParam);
                    case "/log":
                        LogParam logParam = GsonTool.fromJson(requestData, LogParam.class);
                        return executorBiz.log(logParam);
                    default:
                        return new ReturnT<String>(ReturnT.FAIL_CODE, "invalid request, uri-mapping(" + uri + ") not found.");
                }
            } catch (Exception e) {
                logger.error(e.getMessage(), e);
                return new ReturnT<String>(ReturnT.FAIL_CODE, "request error:" + ThrowableUtil.toString(e));
            }
        }
```

- 分了两种情况，第一种情况就是这个任务正在执行，还需要查看绑定的是否是这个任务，如果绑定的不是目前触发参数的任务，就更改。然后判断是哪种类型的执行方式。再考虑是哪种阻塞策略，是丢弃目前任务还是杀死正在跑的任务。最后把执行参数放进触发参数队列，执行参数会等待被调度。

```java
@Override
    public ReturnT<String> run(TriggerParam triggerParam) {
        //加载任务信息和任务处理器
        JobThread jobThread = XxlJobExecutor.loadJobThread(triggerParam.getJobId());
        IJobHandler jobHandler = jobThread != null?jobThread.getHandler():null;
        String removeOldReason = null;

        //判断任务信息和任务处理器是否有效
        //判断glue模式下使用的语言
        GlueTypeEnum glueTypeEnum = GlueTypeEnum.match(triggerParam.getGlueType());
        if(GlueTypeEnum.BEAN == glueTypeEnum){

            //新建任务处理器
            IJobHandler newJobHandler = XxlJobExecutor.loadJobHandler(triggerParam.getExecutorHandler());

            //如果老的任务处理器不等于新的
            if(jobThread != null && jobHandler != newJobHandler ){
                //解放老的处理器
                removeOldReason = "change jobhandler or glue type, and terminate the old job thread.";

                jobThread = null;
                jobHandler = null;
            }

            //让新的处理器有效
            if(jobHandler == null){
                jobHandler = newJobHandler;
                if(jobHandler == null){
                    return new ReturnT<String>(ReturnT.FAIL_CODE, "job handler [" + triggerParam.getExecutorHandler() + "] not found.");
                }
            }

        } else if (GlueTypeEnum.GLUE_GROOVY == glueTypeEnum) {

            //判断老的任务处理器是否还有效
            if (jobThread != null &&
                    !(jobThread.getHandler() instanceof GlueJobHandler
                            && ((GlueJobHandler) jobThread.getHandler()).getGlueUpdatetime()==triggerParam.getGlueUpdatetime() )) {
                // change handler or gluesource updated, need kill old thread
                removeOldReason = "change job source or glue type, and terminate the old job thread.";

                jobThread = null;
                jobHandler = null;
            }

            //判断处理器是否有效
            if(jobHandler == null){
                try {
                    IJobHandler originJobHandler = GlueFactory.getInstance().loadNewInstance(triggerParam.getGlueSource());
                    jobHandler = new GlueJobHandler(originJobHandler, triggerParam.getGlueUpdatetime());
                }catch (Exception e){
                    logger.error(e.getMessage(), e);
                    return new ReturnT<String>(ReturnT.FAIL_CODE, e.getMessage());
                }
            }
        } else if (glueTypeEnum != null && glueTypeEnum.isScript()) {

            //判断老的任务处理器是否有效
            if (jobThread != null &&
                    !(jobThread.getHandler() instanceof ScriptJobHandler
                            && ((ScriptJobHandler) jobThread.getHandler()).getGlueUpdatetime()==triggerParam.getGlueUpdatetime() )) {
                // change script or gluesource updated, need kill old thread
                removeOldReason = "change job source or glue type, and terminate the old job thread.";

                jobThread = null;
                jobHandler = null;
            }

            //判断处理器是否有效
            if(jobHandler == null){
                jobHandler = new ScriptJobHandler(triggerParam.getJobId(), triggerParam.getGlueUpdatetime(), triggerParam.getGlueSource(), GlueTypeEnum.match(triggerParam.getGlueType()));
            }
        }else {
            return new ReturnT<String>(ReturnT.FAIL_CODE, "glueType[" + triggerParam.getGlueType() + "] is not valid.");
        }

        //处理阻塞策略
        if(jobThread != null){
            ExecutorBlockStrategyEnum blockStrategy = ExecutorBlockStrategyEnum.match(triggerParam.getExecutorBlockStrategy(), null);
            if(ExecutorBlockStrategyEnum.DISCARD_LATER == blockStrategy){
                //当正在跑的时候丢弃
                if (jobThread.isRunningOrHasQueue()) {
                    return new ReturnT<String>(ReturnT.FAIL_CODE, "block strategy effect："+ExecutorBlockStrategyEnum.DISCARD_LATER.getTitle());
                }
            } else if (ExecutorBlockStrategyEnum.COVER_EARLY == blockStrategy) {
                //杀死正在跑的任务线程
                if (jobThread.isRunningOrHasQueue()) {
                    removeOldReason = "block strategy effect：" + ExecutorBlockStrategyEnum.COVER_EARLY.getTitle();

                    jobThread = null;
                }
            }else {
                // just queue trigger
            }
        }

        //替换线程（新的或者是无效的）
        if(jobThread == null){
            jobThread = XxlJobExecutor.registJobThread(triggerParam.getJobId(), jobHandler, removeOldReason);
        }

        //把数据推送到队列
        ReturnT<String> pushResult = jobThread.pushTriggerQueue(triggerParam);
        return pushResult;
    }
```

- 第二种情况就是任务从未记录过任务或者要中止目前正在运行的线程，通过注册新线程的方式进行,并把老的方法停止，如果是从未产生过线程，移除的原因为空，如果是其他，会有对应的原因，如果和原来相同也会执行这个

```java
/**
     * 将新任务加入map中并执行，同时替换出旧任务并停止
     * @param jobId
     * @param handler
     * @param removeOldReason
     * @return
     */
    public static JobThread registJobThread(int jobId, IJobHandler handler, String removeOldReason){
        JobThread newJobThread = new JobThread(jobId, handler);
        newJobThread.start();
        logger.info(">>>>>>>>>>> xxl-job regist JobThread success, jobId:{}, handler:{}", new Object[]{jobId, handler});

        JobThread oldJobThread = jobThreadRepository.put(jobId, newJobThread);	// putIfAbsent | oh my god, map's put method return the old value!!!
        if(oldJobThread != null){
            oldJobThread.toStop(removeOldReason);
            oldJobThread.interrupt();
        }
        return newJobThread;
    }
```

- 执行线程，接收队列参数，并生成对应日志文件信息与其他信息，再调用MethodJobHandler种的execute功能执行获取到的方法，并执行

```java
 public void run(){

        //初始化
        try {
            handler.init();
        }catch (Throwable e){
            logger.error(e.getMessage() ,e);
        }

        //执行
        while (!toStop){
            running = false;
            idleTimes++;

            TriggerParam triggerParam = null;
            try {
                //为了避免线程阻塞，调用poll方法，会等待三秒如果队列种没有参数
                triggerParam = triggerQueue.poll(3L, TimeUnit.SECONDS);
                if(triggerParam != null){
                    running = true;
                    idleTimes = 0;
                    triggerLogIdSet.remove(triggerParam.getLogId());

                    //日志文件名 "logPath/yyyy-MM-dd/9999.log"
                    String logFileName = XxlJobFileAppender.makeLogFileName(new Date(triggerParam.getLogDateTime()),triggerParam.getLogId());
                    XxlJobContext xxlJobContext = new XxlJobContext(
                            triggerParam.getJobId(),
                            triggerParam.getExecutorParams(),
                            logFileName,
                            triggerParam.getBroadcastIndex(),
                            triggerParam.getBroadcastTotal());

                    //初始化任务内容
                    XxlJobContext.setXxlJobContext(xxlJobContext);

                    //执行
                    XxlJobHelper.log("<br>----------- xxl-job job execute start -----------<br>----------- Param:" + xxlJobContext.getJobParam());

                    //超时处理
                    if(triggerParam.getExecutorTimeout() > 0){
                        //限制超时时间
                        Thread futureThread = null;
                        try {
                            FutureTask<Boolean> futureTask = new FutureTask<Boolean>(new Callable<Boolean>() {
                                @Override
                                public Boolean call() throws Exception {

                                    //初始化工作内容
                                    XxlJobContext.setXxlJobContext(xxlJobContext);

                                    handler.execute();
                                    return true;
                                }
                            });
                            futureThread = new Thread(futureTask);
                            futureThread.start();
                            Boolean tempResult = futureTask.get(triggerParam.getExecutorTimeout(), TimeUnit.SECONDS);
                        }catch (TimeoutException e){

                            XxlJobHelper.log("<br>----------- xxl-job job execute timeout");
                            XxlJobHelper.log(e);

                            // handle result
                            XxlJobHelper.handleTimeout("job execute timeout ");
                        }finally {
                            futureThread.interrupt();
                        }
                    }else {
                        //执行即可
                        handler.execute();
                    }

                    //有效的执行处理数据
                    // valid execute handle data
                    if (XxlJobContext.getXxlJobContext().getHandleCode() <= 0) {
                        XxlJobHelper.handleFail("job handle result lost.");
                    } else {
                        String tempHandleMsg = XxlJobContext.getXxlJobContext().getHandleMsg();
                        tempHandleMsg = (tempHandleMsg!=null&&tempHandleMsg.length()>50000)
                                ?tempHandleMsg.substring(0, 50000).concat("...")
                                :tempHandleMsg;
                        XxlJobContext.getXxlJobContext().setHandleMsg(tempHandleMsg);
                    }
                    XxlJobHelper.log("<br>----------- xxl-job job execute end(finish) -----------<br>----------- Result: handleCode="
                            + XxlJobContext.getXxlJobContext().getHandleCode()
                            + ", handleMsg = "
                            + XxlJobContext.getXxlJobContext().getHandleMsg()
                    );
                }else {
                    if(idleTimes > 30){
                        if(triggerQueue.size() == 0){
                            XxlJobExecutor.removeJobThread(jobId, "excutor idel times over limit.");
                        }
                    }
                }
            }catch (Throwable e){
                if (toStop) {
                    XxlJobHelper.log("<br>----------- JobThread toStop, stopReason:" + stopReason);
                }

                // handle result
                StringWriter stringWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stringWriter));
                String errorMsg = stringWriter.toString();

                XxlJobHelper.handleFail(errorMsg);

                XxlJobHelper.log("<br>----------- JobThread Exception:" + errorMsg + "<br>----------- xxl-job job execute end(error) -----------");
            }finally {
                //检查参数是否为空
                if(triggerParam != null){
                    //判断是否正常中止
                    if(!toStop){
                        // commonm
                        TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                                triggerParam.getLogId(),
                                triggerParam.getLogDateTime(),
                                XxlJobContext.getXxlJobContext().getHandleCode(),
                                XxlJobContext.getXxlJobContext().getHandleMsg() )
                        );
                    }else {
                        //是被异常中止的
                        TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                                triggerParam.getLogId(),
                                triggerParam.getLogDateTime(),
                                XxlJobContext.HANDLE_CODE_FAIL,
                                stopReason + " [job running, killed]" )
                        );
                    }
                }
            }
        }

        //这段代码用于处理等待执行的触发请求，即使它们没有实际执行，也会生成相应的回调信息，并将其传递给回调处理线程，以便进行回调处理
        while (triggerQueue != null && triggerQueue.size() > 0){
            TriggerParam triggerParam = triggerQueue.poll();
            if(triggerParam != null){
                //回调信息中写入线程中止
                TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                        triggerParam.getLogId(),
                        triggerParam.getLogDateTime(),
                        XxlJobContext.HANDLE_CODE_FAIL,
                        stopReason + " [job not executed, in the job queue, killed.]")
                );
            }
        }

        //释放资源
        try {
            handler.destroy();
        }catch (Throwable e){
            logger.error(e.getMessage() , e);
        }
        logger.info(">>>>>>>>>>> xxl-job JobThread stoped, hashCode:{}", Thread.currentThread());

    }
```

- handler方法通过实现那边的config注册可以把执行方法bean和执行方法存进Map,方便之后的调用，可以直接从Map种取出

```java
protected void registJobHandler(XxlJob xxlJob, Object bean, Method executeMethod){
        if(xxlJob ==null){
            return;
        }

        //获取xxl-job注解中的值
        String name = xxlJob.value();
        //获取对象的类型信息并执行与该类型相关的操作
        Class<?> clazz = bean.getClass();
        String methodName = executeMethod.getName();
        if (name.trim().length() == 0) {
            throw new RuntimeException("xxl-job method-jobhandler name invalid, for[" + clazz + "#" + methodName + "] .");
        }

        //存在同名的任务处理器，抛出异常
        if(loadJobHandler(name) != null){
            throw new RuntimeException("xxl-job jobhandler[" + name + "] naming conflicts.");
        }

        //绕过 Java 的访问控制
        executeMethod.setAccessible(true);

        //初始化和销毁方法
        Method initMethod = null;
        Method destroyMethod = null;

        if(xxlJob.init().trim().length() > 0){
            try {
                initMethod = clazz.getDeclaredMethod(xxlJob.init());
                initMethod.setAccessible(true);
            } catch (NoSuchMethodException e) {
                throw new RuntimeException("xxl-job method-jobhandler initMethod invalid, for[" + clazz + "#" + methodName + "] .");
            }
        }
        if (xxlJob.destroy().trim().length() > 0) {
            try {
                destroyMethod = clazz.getDeclaredMethod(xxlJob.destroy());
                destroyMethod.setAccessible(true);
            } catch (NoSuchMethodException e) {
                throw new RuntimeException("xxl-job method-jobhandler destroyMethod invalid, for[" + clazz + "#" + methodName + "] .");
            }
        }

        //注册处理方法
        registJobHandler(name, new MethodJobHandler(bean, executeMethod, initMethod, destroyMethod));

    }
```

- 执行函数，用户调用注册的方法执行激活，至此，一次执行结束

```java
/**
     * 执行方法体中的函数，并传递参数
     * @throws Exception
     */
    @Override
    public void execute() throws Exception {
        //这行代码的作用是获得 method 方法的参数类型数组，即该方法的参数类型列表
        Class<?>[] paramTypes = method.getParameterTypes();
        if(paramTypes.length > 0){
            method.invoke(target, new Object[paramTypes.length]);     //方法参数不能是原始参数
        }else {
            method.invoke(target);
        }
    }
```



##### 2.代码启动一直执行过程

- 前端发送请求

```java
@RequestMapping("/start")
    @ResponseBody
    public ReturnT<String> start(int id) {
        return xxlJobService.start(id);
    }
```

- 通过判断数据库中任务的执行状态和任务的下次执行时间去判断任务的执行状态，只需要更改一次任务的执行状态和下次执行时间，然后配置类会自动导出任务的数据，执行。

```java
@Override
    public ReturnT<String> start(int id) {

        XxlJobInfo xxlJobInfo = xxlJobInfoDao.loadById(id);

        //判断调度策略是否正确
        ScheduleTypeEnum scheduleTypeEnum = ScheduleTypeEnum.match(xxlJobInfo.getScheduleType(), ScheduleTypeEnum.NONE);
        if (ScheduleTypeEnum.NONE == scheduleTypeEnum) {
            return new ReturnT<String>(ReturnT.FAIL_CODE, (I18nUtil.getString("schedule_type_none_limit_start")) );
        }

        //去得到下一次的触发时间，但是要在现在基础上加5s避免预读周期
        long nextTriggerTime = 0;
        try {
            Date nextValidTime = JobScheduleHelper.generateNextValidTime(xxlJobInfo, new Date(System.currentTimeMillis() + JobScheduleHelper.PRE_READ_MS));
            if (nextValidTime == null) {
                return new ReturnT<String>(ReturnT.FAIL_CODE, (I18nUtil.getString("schedule_type")+I18nUtil.getString("system_unvalid")) );
            }
            nextTriggerTime = nextValidTime.getTime();
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return new ReturnT<String>(ReturnT.FAIL_CODE, (I18nUtil.getString("schedule_type")+I18nUtil.getString("system_unvalid")) );
        }

        xxlJobInfo.setTriggerStatus(1);
        xxlJobInfo.setTriggerLastTime(0);
        xxlJobInfo.setTriggerNextTime(nextTriggerTime);

        xxlJobInfo.setUpdateTime(new Date());
        xxlJobInfoDao.update(xxlJobInfo);
        return ReturnT.SUCCESS;
    }
```





- 实现InitializingBean, DisposableBean接口类，达到启动和关闭Spring时会自动生成和调用调度器

```java
 @Override     //实现了 InitializingBean接口，初始化调用此方法
    public void afterPropertiesSet() throws Exception {
        //利用静态声明的只会加载一次的特性，初始化一个单例对象。
        adminConfig =this;

        xxlJobScheduler = new XxlJobScheduler();

        xxlJobScheduler.init();

    }
```

- 调用一个线程，从数据库中导出满足条件的任务（满足触发状态和触发时间在范围内），然后循环执行任务表中的任务
  - 超过了过期时间：根据执行策略判断是立马再执行一次，还是不管，更新下次执行时间
  - 在过期时间范围内：立马执行，然后判断下次执行时间是否在五秒内，是就加进时间环内，不是就刷新时间
  - 没过期：放进时间环内等待执行
- 把数据存进数据库然后关闭数据库链接吗，执行成功继续执行，执行不成功就会让线程睡眠一定时间

```java
//协调线程
        scheduleThread = new Thread(new Runnable() {

            @Override
            public void run() {

                try {
                    //下5秒之后执行一次，等待服务器启动，为了凑到整数秒，且时间不超过五秒
                    TimeUnit.MILLISECONDS.sleep(5000 - System.currentTimeMillis()%1000 );
                } catch (InterruptedException e) {
                    if (!scheduleThreadToStop) {
                        logger.error(e.getMessage(), e);
                    }
                }
                logger.info(">>>>>>>>> init xxl-job admin scheduler success.");

                // pre-read count: treadpool-size * trigger-qps (each trigger cost 50ms, qps = 1000/50 = 20) 每个触发器花费50ms,每个线程单位时间内处理20任务,最多同时处理300*20=6000任务
                int preReadCount = (XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax() + XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax()) * 20;

                while (!scheduleThreadToStop){

                    //扫描任务
                    long start = System.currentTimeMillis();

                    Connection conn = null;
                    Boolean connAutoCommit = null;
                    PreparedStatement preparedStatement = null;

                    boolean preReadSuc = true;
                    try {
                        //设置手动提交
                        conn = XxlJobAdminConfig.getAdminConfig().getDataSource().getConnection();
                        connAutoCommit = conn.getAutoCommit();
                        conn.setAutoCommit(false);

                        //获取任务调度锁表内数据信息,加写锁,获得排他锁
                        preparedStatement = conn.prepareStatement(  "select * from xxl_job_lock where lock_name = 'schedule_lock' for update" );
                        preparedStatement.execute();

                        //从任务表预读
                        long nowTime = System.currentTimeMillis(); // //获取当前时间后5秒,同时最多负载的分页数
                        //得到满足执行状态同时下次执行时间在执行范围内的所有任务
                        List<XxlJobInfo> scheduleList = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleJobQuery(nowTime + PRE_READ_MS, preReadCount);
                        if(scheduleList != null && scheduleList.size() > 0){

                            //放进时间环
                            for(XxlJobInfo jobInfo : scheduleList){

                                //跳过时间环
                                if(nowTime > jobInfo.getTriggerNextTime()+PRE_READ_MS){ //触发器过期时间>5s
                                    //trigger-expire > 5s：pass && make next-trigger-time
                                    logger.warn(">>>>>>>>>>> xxl-job, schedule misfire, jobId = " + jobInfo.getId());

                                    //调度过期匹配
                                    //- 忽略：调度过期后，忽略过期的任务，从当前时间开始重新计算下次触发时间；
                                    //- 立即执行一次：调度过期后，立即执行一次，并从当前时间开始重新计算下次触发时间；
                                    MisfireStrategyEnum misfireStrategyEnum = MisfireStrategyEnum.match(jobInfo.getMisfireStrategy(), MisfireStrategyEnum.DO_NOTHING);
                                    if(MisfireStrategyEnum.FIRE_ONCE_NOW == misfireStrategyEnum){
                                        //执行触发器
                                        JobTriggerPoolHelper.trigger(jobInfo.getId(), TriggerTypeEnum.MISFIRE, -1, null, null, null);
                                        logger.debug(">>>>>>>>>>> xxl-job, schedule push trigger : jobId = " + jobInfo.getId() );
                                    }

                                    //更新下次执行时间
                                    refreshNextValidTime(jobInfo, new Date());
                                } else if (nowTime > jobInfo.getTriggerNextTime()) {  //触发器过期时间<5s
                                    // 1、trigger  //执行触发器
                                    JobTriggerPoolHelper.trigger(jobInfo.getId(), TriggerTypeEnum.CRON, -1, null, null, null);
                                    logger.debug(">>>>>>>>>>> xxl-job, schedule push trigger : jobId = " + jobInfo.getId() );

                                    //2.更新下次执行时间
                                    refreshNextValidTime(jobInfo, new Date());

                                    //下次触发时间在当前时间往后5秒范围内
                                    if(jobInfo.getTriggerStatus() == 1 && nowTime + PRE_READ_MS > jobInfo.getTriggerNextTime()){

                                        //获取下次执行时间
                                        int ringSecond = (int)((jobInfo.getTriggerNextTime()/1000)%60);

                                        //放进时间环
                                        pushTimeRing(ringSecond, jobInfo.getId());

                                        //更新下次执行时间
                                        refreshNextValidTime(jobInfo, new Date(jobInfo.getTriggerNextTime()));

                                    }
                                }else {
                                    //未来五秒以内执行的所有任务添加到ringData
                                    //得到放上环的时间
                                    int ringSecond = (int)((jobInfo.getTriggerNextTime()/1000)%60);

                                    //把时间戳和任务id放进环里
                                    pushTimeRing(ringSecond, jobInfo.getId());

                                    //更新下次触发时间
                                    refreshNextValidTime(jobInfo, new Date(jobInfo.getTriggerNextTime()));

                                }
                            }

                            //更新执行时间和上次执行时间到数据库
                            for(XxlJobInfo jobInfo:scheduleList){
                                XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleUpdate(jobInfo);
                            }

                        }else {
                            preReadSuc = false;
                        }

                        // tx stop


                    }catch (Exception e){
                        if (!scheduleThreadToStop) {
                            logger.error(">>>>>>>>>>> xxl-job, JobScheduleHelper#scheduleThread error:{}", e);
                        }
                    }finally {

                        //事务提交
                        if (conn != null) {
                            try {
                                conn.commit();
                            } catch (SQLException e) {
                                if (!scheduleThreadToStop) {
                                    logger.error(e.getMessage(), e);
                                }
                            }
                            try {
                                conn.setAutoCommit(connAutoCommit);
                            } catch (SQLException e) {
                                if (!scheduleThreadToStop) {
                                    logger.error(e.getMessage(), e);
                                }
                            }
                            try {
                                conn.close();
                            } catch (SQLException e) {
                                if (!scheduleThreadToStop) {
                                    logger.error(e.getMessage(), e);
                                }
                            }
                        }

                        //关闭数据库执行连接
                        if (null != preparedStatement) {
                            try {
                                preparedStatement.close();
                            } catch (SQLException e) {
                                if (!scheduleThreadToStop) {
                                    logger.error(e.getMessage(), e);
                                }
                            }
                        }
                    }
                    long cost = System.currentTimeMillis()-start;


                    //等待时间
                    if (cost < 1000) {  // scan-overtime, not wait
                        try {
                            // pre-read period: success > scan each second; fail > skip this period;
                            //若执行成功,下一秒继续执行。执行失败或没查询出数据则5秒执行一次。
                            TimeUnit.MILLISECONDS.sleep((preReadSuc?1000:PRE_READ_MS) - System.currentTimeMillis()%1000);
                        } catch (InterruptedException e) {
                            if (!scheduleThreadToStop) {
                                logger.error(e.getMessage(), e);
                            }
                        }
                    }
                }
                logger.info(">>>>>>>>>>> xxl-job, JobScheduleHelper#scheduleThread stop");
            }
        });
        scheduleThread.setDaemon(true);
        scheduleThread.setName("xxl-job, admin JobScheduleHelper#scheduleThread");
        scheduleThread.start();
```

- 根据时间从Map中取出任务id以及相关信息，然后根据触发相关任务，之后的触发逻辑与执行一次是相同的

```java
//环线程
        ringThread = new Thread(new Runnable() {

            @Override
            public void run() {

                while (!ringThreadToStop){

                    //单个秒数
                    try{
                        //凑到整秒
                        TimeUnit.MILLISECONDS.sleep(1000 - System.currentTimeMillis() % 1000);
                    }catch (InterruptedException e){
                        if (!ringThreadToStop) {
                            logger.error(e.getMessage(), e);
                        }
                    }

                    try {
                        //第二秒
                        List<Integer> ringItemData = new ArrayList<>();
                        int nowSecond = Calendar.getInstance().get(Calendar.SECOND); // 避免处理耗时太长，跨过刻度，向前校验一个刻度
                        for (int i = 0; i < 2; i++) {
                            //假设现在为1秒，那么执行任务之后，5秒之后的任务分别会添加到23456下标位置
                            // i=1：（1+60-1）%60=0
                            // i=2：（1+60-2）%60=59
                            List<Integer> tmpData = ringData.remove( (nowSecond+60-i)%60 );
                            if (tmpData != null) {
                                ringItemData.addAll(tmpData);
                            }
                        }

                        //时间环触发
                        logger.debug(">>>>>>>>>>> xxl-job, time-ring beat : " + nowSecond + " = " + Arrays.asList(ringItemData) );
                        if(ringItemData.size() > 0){
                            //执行触发器
                            for(int jobId: ringItemData){
                                //执行触发器
                                JobTriggerPoolHelper.trigger(jobId, TriggerTypeEnum.CRON,-1,null,null,null);
                            }
                            //清理
                            ringItemData.clear();
                        }
                    }catch (Exception e){
                        if (!ringThreadToStop) {
                            logger.error(">>>>>>>>>>> xxl-job, JobScheduleHelper#ringThread error:{}", e);
                        }
                    }
                }
                logger.info(">>>>>>>>>>> xxl-job, JobScheduleHelper#ringThread stop");
            }
        });
        ringThread.setDaemon(true);
        ringThread.setName("xxl-job, admin JobScheduleHelper#ringThread");
        ringThread.start();
```



##### 3.拦截器以及权限判断

- 权限拦截器,会判断用户是否登录过，如果没登录就会跳转登录页面。

```java
@Component
public class PermissionInterceptor implements AsyncHandlerInterceptor {

    @Resource
    private LoginService loginService;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)throws Exception{

        //为了确保在拦截器中只对真正的控制器方法进行特定的操作，而不会影响其他非控制器方法的请求处理(就是controller层的路径方法)
        if(!(handler instanceof HandlerMethod)){
            return true;      //可以执行下一个拦截器
        }

        //判断是否登录  还有就是是否具有管理员权限
        boolean needLogin = true;
        boolean needAdminuser = false;
        HandlerMethod method = (HandlerMethod) handler;
        PermissionLimit permission = method.getMethodAnnotation(PermissionLimit.class);

        //通过注解去得到权限
        if(permission != null){
            needLogin = permission.limit();
            needAdminuser = permission.adminuser();
        }

        //检查用户是否登录，没有就跳转登录页面
        if(needLogin){
            XxlJobUser loginUser = loginService.ifLogin(request,response);

            if(loginUser == null){
                response.setStatus(302);
                response.setHeader("location",request.getContextPath()+"/toLogin");
                return false;
            }

            if(needAdminuser && loginUser.getRole() !=1){
                throw new RuntimeException(I18nUtil.getString("system_permission_limit"));
            }

            request.setAttribute(LoginService.LOGIN_IDENTITY_KEY, loginUser);
        }

        return true;   //进入下一个拦截器
    }

}
```

- 判断传回去的视图和cookie是否为空，并添加国际化方法

```java
@Component
public class CookieInterceptor implements AsyncHandlerInterceptor {

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
                           ModelAndView modelAndView)throws Exception{

        //判断视图和cookie不为空
        if(modelAndView != null && request.getCookies() != null && request.getCookies().length > 0){
            HashMap<String, Cookie> cookieMap = new HashMap<String,Cookie>();
            for(Cookie ck : request.getCookies()){
                cookieMap.put(ck.getName(), ck);
            }
            modelAndView.addObject("cookieMap",cookieMap);
        }

        //添加国际化方法到视图对象中
        if(modelAndView != null){
            modelAndView.addObject("I18nUtil", FtlUtil.generateStaticModel(I18nUtil.class.getName()));
        }
    }
}

```

- 让之前两个拦截器生效，作用域全局

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Resource
    private PermissionInterceptor permissionInterceptor;

    @Resource
    private CookieInterceptor cookieInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(permissionInterceptor).addPathPatterns("/**");
        registry.addInterceptor(cookieInterceptor).addPathPatterns("/**");
    }

}

```



##### 4.初始化线程池

- 初始化线程池，建立快慢线程池

```java
 public void start(){
        //最大200线程，最多处理1000任务
        fastTriggerPool = new ThreadPoolExecutor(
                10,
                XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax(),
                60L,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue<Runnable>(1000),
                new ThreadFactory() {
                    @Override   //创建线程
                    public Thread newThread(Runnable r) {
                        return new Thread(r, "xxl-job, admin JobTriggerPoolHelper-fastTriggerPool-" + r.hashCode());
                    }
                });

        //最大100线程，最多处理2000任务
        //一分钟内超时10次，则采用慢触发器执行
        slowTriggerPool = new ThreadPoolExecutor(
                10,
                XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax(),
                60L,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue<Runnable>(2000),
                new ThreadFactory() {
                    @Override
                    public Thread newThread(Runnable r) {
                        return new Thread(r, "xxl-job, admin JobTriggerPoolHelper-slowTriggerPool-" + r.hashCode());
                    }
                });
    }
```

- 根据超时次数切换快慢线程池

```java
 public void addTrigger(final int jobId,
                           final TriggerTypeEnum triggerType,
                           final int failRetryCount,
                           final String executorShardingParam,
                           final String executorParam,
                           final String addressList) {

        //默认使用快线程池，如果一分钟内超时十次，就使用慢线程池
        ThreadPoolExecutor triggerPool = fastTriggerPool;
        AtomicInteger jobTimeoutCount = jobTimeoutCountMap.get(jobId);
        if(jobTimeoutCount != null && jobTimeoutCount.get() > 10){    //一个任务一分钟超时十次换到慢线程池
            triggerPool = slowTriggerPool;
        }

        //执行
        triggerPool.execute(new Runnable() {
            @Override
            public void run() {
                long start = System.currentTimeMillis();

                try {
                    //使用触发器
                    XxlJobTrigger.trigger(jobId, triggerType, failRetryCount, executorShardingParam, executorParam, addressList);
                }catch (Exception e){
                    logger.error(e.getMessage(), e);
                }finally {
                    //检查任务时间超时，判断是否在同一分钟内
                    long minTim_now = System.currentTimeMillis()/60000;
                    if(minTim != minTim_now){
                        minTim = minTim_now;
                        jobTimeoutCountMap.clear();
                    }

                    //增加超时计数映射
                    long cost  = System.currentTimeMillis()-start;
                    if(cost > 500){    //超时阈值 500 毫秒
                        AtomicInteger timeoutCount = jobTimeoutCountMap.putIfAbsent(jobId,new AtomicInteger(1));
                        //如果之前这种任务超时就存在,增加1
                        if(timeoutCount != null){
                            timeoutCount.incrementAndGet();
                        }
                    }

                }

            }
        });
    }
```



##### 5.初始化注册器监视线程

- 初始化线程池和注册线程，线程用来维护自动注册的执行器

```java
/*
	1.初始化注册或者删除线程池，主要负责客户端注册或者销毁到xxl_job_registry表
    2.剔除超时注册机器
    3.更新xxl_job_group执行器地址列表
	*/
    public void start(){

        //初始化注册或者删除线程池
        registryOrRemoveThreadPool = new ThreadPoolExecutor(
                2,
                10,
                30L,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue<Runnable>(2000),
                new ThreadFactory() {
                    @Override
                    public Thread newThread(Runnable r) {
                        return new Thread(r, "xxl-job, admin JobRegistryMonitorHelper-registryOrRemoveThreadPool-" + r.hashCode());
                    }
                },

                //注意:这里的拒绝策略就是再次执行...^_^'''
                new RejectedExecutionHandler() {
                    @Override
                    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
                        r.run();
                        logger.warn(">>>>>>>>>>> xxl-job, registry or remove too fast, match threadpool rejected handler(run now).");
                    }
                });


        //30秒执行一次,维护注册表信息， 判断在线超时时间90s
        registryMonitorThread = new Thread(new Runnable() {

            @Override
            public void run() {
                while (!toStop){
                    try {

                        //查询自动注册的数据
                        //这里如果没添加自动注册的数据，则不会进入该方法，然后删除register表中超时注册数据。
                        List<XxlJobGroup> groupList = XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().findByAddressType(0);
                        if(groupList != null && !groupList.isEmpty()){
                            // 1):从注册表中删除超时90s的机器,不分是否自动注册
                            List<Integer> ids = XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().findDead(RegistryConfig.DEAD_TIMEOUT, new Date());
                            if(ids != null && ids.size() > 0){
                                XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().removeDead(ids);
                            }
                        }

                        // 获取所有在线机器,注册表: 见"xxl_job_registry"表, "执行器" 在进行任务注册时将会周期性维护一条注册记录，
                        // 即机器地址和AppName的绑定关系; "调度中心" 从而可以动态感知每个AppName在线的机器列表;
                        HashMap<String, List<String>> appAddressMap = new HashMap<String, List<String>>();
                        //不分是否自动注册
                        List<XxlJobRegistry> list = XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().findAll(RegistryConfig.DEAD_TIMEOUT, new Date());
                        if(list != null){
                            for(XxlJobRegistry item : list){
                                //将注册类型为EXECUTOR的XxlJobRegistry集合改装成appname=>设置触发器的ip地址
                                if(RegistryConfig.RegistType.EXECUTOR.name().equals(item.getRegistryGroup())){
                                    //AppName: 每个执行器机器集群的唯一标示, 任务注册以 "执行器" 为最小粒度进行注册; 每个任务通过其绑定的执行器可感知对应的执行器机器列表;
                                    String appname = item.getRegistryKey();
                                    List<String> registryList = appAddressMap.get(appname);
                                    if(registryList == null){
                                        registryList = new ArrayList<String>();
                                    }

                                    if(!registryList.contains(item.getRegistryValue())){
                                        registryList.add(item.getRegistryValue());
                                    }
                                    appAddressMap.put(appname, registryList);
                                }
                            }
                        }

                        //更新xxl_job_group执行器地址列表
                        for(XxlJobGroup group:groupList){
                            List<String> registryList = appAddressMap.get(group.getAppname());
                            String addressListStr = null;   //将所有配置触发器的ip地址，使用,拼接
                            if(registryList != null && !registryList.isEmpty()){
                                //排序
                                Collections.sort(registryList);
                                StringBuilder addressListSB = new StringBuilder();
                                for(String item:registryList){
                                    addressListSB.append(",");
                                }
                                addressListStr = addressListSB.toString();
                                addressListStr = addressListStr.substring(0,addressListStr.length()-1);
                            }
                            group.setAddressList(addressListStr);  //更新了触发器的地址
                            group.setUpdateTime(new Date());  //更新修改时间

                            //将注册表中appname对应的多条ip地址，整成appname-> ips(IP1,IP2,IP3)格式存储xxl_job_group表中，只针对自动注册。
                            XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().update(group);
                        }

                    }catch (Exception e){
                        if (!toStop) {
                            logger.error(">>>>>>>>>>> xxl-job, job registry monitor thread error:{}", e);
                        }
                    }
                    try {
                        //让当前线程休息
                        TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT);
                    }catch (InterruptedException e){
                        if (!toStop) {
                            logger.error(">>>>>>>>>>> xxl-job, job registry monitor thread error:{}", e);
                        }
                    }
                }
                logger.info(">>>>>>>>>>> xxl-job, job registry monitor thread stop");
            }
        });
        registryMonitorThread.setDaemon(true);    //设置为后台线程
        registryMonitorThread.setName("xxl-job, admin JobRegistryMonitorHelper-registryMonitorThread");   //设置名字
        registryMonitorThread.start();    //开始线程
    }
```



##### 6.初始化失败事件监听器

- 初始化失败事件监听器，从log文件数据库中导出所有的失败事件的log文件对象id，然后根据id导入任务和log对象的详细信息，根据重新执行次数再次执行任务。然后发送邮件到指定邮箱

```java
public void start(){
        monitorThread = new Thread(new Runnable() {
            @Override
            public void run() {

                //监视器
                while (!toStop){
                    try {
                        //将注册表中appname对应的多条ip地址，整成appname-> ips(IP1,IP2,IP3)格式存储xxl_job_group表中，只针对自动注册。
                        List<Long> failLogIds = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findFailJobLogIds(1000);
                        if(failLogIds != null && !failLogIds.isEmpty()){//1:执行触发器成功,返回值失败.2:触发器失败
                            for(long failLogId : failLogIds){

                                //加锁，乐观修改alarm_status=-1  以数据库的键值为锁
                                int lockRet = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, 0, -1);
                                if (lockRet < 1) {
                                    continue;
                                }
                                //得到日志信息和任务信息
                                XxlJobLog log = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().load(failLogId);
                                XxlJobInfo info = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().loadById(log.getJobId());

                                //失败重试监视器
                                if (log.getExecutorFailRetryCount() > 0) {//若可重试次数>0,则再次执行触发器
                                    JobTriggerPoolHelper.trigger(log.getJobId(), TriggerTypeEnum.RETRY, (log.getExecutorFailRetryCount()-1), log.getExecutorShardingParam(), log.getExecutorParam(), null);
                                    String retryMsg = "<br><br><span style=\"color:#F39C12;\" > >>>>>>>>>>>"+ I18nUtil.getString("jobconf_trigger_type_retry") +"<<<<<<<<<<< </span><br>";
                                    log.setTriggerMsg(log.getTriggerMsg() + retryMsg);
                                    XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateTriggerInfo(log);
                                }

                                //fail alarm monitor 失败警告监视器
                                int newAlarmStatus = 0;		// 告警状态：0-默认、-1=锁定状态、1-无需告警、2-告警成功、3-告警失败
                                if(info != null){
                                    //判断发送邮件是否成功
                                    boolean alarmResult = XxlJobAdminConfig.getAdminConfig().getJobAlarmer().alarm(info,log);
                                    newAlarmStatus = alarmResult?2:3;
                                }else {//没设置报警邮箱，则更改状态为不需要告警
                                    newAlarmStatus = 1;
                                }
                                //释放锁
                                XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, -1, newAlarmStatus);
                            }
                        }
                    }catch (Exception e){
                        if (!toStop) {
                            logger.error(">>>>>>>>>>> xxl-job, job fail monitor thread error:{}", e);
                        }
                    }
                    try {
                        TimeUnit.SECONDS.sleep(10);
                    } catch (Exception e) {
                        if (!toStop) {
                            logger.error(e.getMessage(), e);
                        }
                    }
                }
                logger.info(">>>>>>>>>>> xxl-job, job fail monitor thread stop");
            }
        });
        monitorThread.setDaemon(true);
        monitorThread.setName("xxl-job, admin JobFailMonitorHelper");
        monitorThread.start();
    }
```

- 尝试发送报错邮件

```java
/**
     * 这段代码用于触发作业执行时的告警操作，遍历所有的告警器执行告警任务，只要有一个失败，就返回 false，否则返回 true。
     */
    public boolean alarm(XxlJobInfo info, XxlJobLog jobLog){

        boolean result = false;
        if(jobAlarmList != null && jobAlarmList.size() > 0){
            result = true;
            for(JobAlarm alarm: jobAlarmList){
                boolean resultItem = false;
                try {
                    resultItem = alarm.doAlarm(info, jobLog);
                }catch (Exception e){
                    logger.error(e.getMessage(),e);
                }
                if(!resultItem){
                    result = false;
                }
            }
        }
        return result;
    }
```

- x详细发送邮件代码参照发送邮件实现类........



##### 7.将丢失主机信息调度日志更改状态

- 调度记录停留在 "运行中" 状态超过10min，且对应执行器心跳注册失败不在线，则将本地调度主动标记失败

```java
public void start(){

        //针对回调函数处理的线程池
        callbackThreadPool = new ThreadPoolExecutor(
                2,
                20,
                30L,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue<Runnable>(3000),
                new ThreadFactory() {
                    @Override
                    public Thread newThread(Runnable r) {
                        return new Thread(r, "xxl-job, admin JobLosedMonitorHelper-callbackThreadPool-" + r.hashCode());
                    }
                },
                new RejectedExecutionHandler() {
                    @Override
                    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
                        r.run();
                        logger.warn(">>>>>>>>>>> xxl-job, callback too fast, match threadpool rejected handler(run now).");
                    }
                });

        //监视者线程
        monitorThread = new Thread(new Runnable() {

            @Override
            public void run() {


                // wait for JobTriggerPoolHelper-init
                try {
                    TimeUnit.MILLISECONDS.sleep(50);
                } catch (InterruptedException e) {
                    if (!toStop) {
                        logger.error(e.getMessage(), e);
                    }
                }

                //监视器
                while (!toStop){
                    try {
                        // 任务结果丢失处理：调度记录停留在 "运行中" 状态超过10min，且对应执行器心跳注册失败不在线，则将本地调度主动标记失败；
                        Date losedTime = DateUtil.addMinutes(new Date(), -10);//调度日志表： 用于保存XXL-JOB任务调度的历史信息，如调度结果、执行结果、调度入参、调度机器和执行器等等；
                        List<Long> losedJobIds = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findLostJobIds(losedTime);

                        if(losedJobIds != null && losedJobIds.size() > 0){
                            for(Long logid : losedJobIds){
                                XxlJobLog jobLog = new XxlJobLog();
                                jobLog.setId(logid);

                                jobLog.setHandleTime(new Date());
                                jobLog.setHandleCode(ReturnT.FAIL_CODE);
                                jobLog.setHandleMsg(I18nUtil.getString("joblog_lost_fail"));

                                //更改处理状态
                                XxlJobCompleter.updateHandleInfoAndFinish(jobLog);
                            }
                        }

                    }catch (Exception e){
                        if (!toStop) {
                            logger.error(">>>>>>>>>>> xxl-job, job fail monitor thread error:{}", e);
                        }
                    }
                    try {
                        TimeUnit.SECONDS.sleep(60);
                    } catch (Exception e) {
                        if (!toStop) {
                            logger.error(e.getMessage(), e);
                        }
                    }
                }
                logger.info(">>>>>>>>>>> xxl-job, JobLosedMonitorHelper stop");
            }
        });
        monitorThread.setDaemon(true);
        monitorThread.setName("xxl-job, admin JobLosedMonitorHelper");
        monitorThread.start();
    }
```



##### 8.统计任务运行信息，并删除过期日志

- 统计任务运行信息，并删除过期日志

```java
public void start(){

        logrThread = new Thread(new Runnable() {
            @Override
            public void run() {

                //记录上次清除日志时间
                long lastCleanLogTime = 0;

                while (!toStop){
                    //刷新三天内的日志

                    try {
                        for(int i = 0; i < 3; i++){

                            //分别统计今天,昨天,前天0~24点的数据
                            //从日历出得到信息
                            Calendar itemDay = Calendar.getInstance();
                            itemDay.add(Calendar.DAY_OF_MONTH, -i);
                            itemDay.set(Calendar.HOUR_OF_DAY, 0);
                            itemDay.set(Calendar.MINUTE, 0);
                            itemDay.set(Calendar.SECOND, 0);
                            itemDay.set(Calendar.MILLISECOND, 0);

                            //设置开始时间
                            Date todayFrom = itemDay.getTime();

                            //设置结束时间
                            itemDay.set(Calendar.HOUR_OF_DAY, 23);
                            itemDay.set(Calendar.MINUTE, 59);
                            itemDay.set(Calendar.SECOND, 59);
                            itemDay.set(Calendar.MILLISECOND, 999);

                            //设置结束时间
                            Date todayTo = itemDay.getTime();

                            //每分钟刷新一次日志信息
                            //设置默认值
                            XxlJobLogReport xxlJobLogReport = new XxlJobLogReport();
                            xxlJobLogReport.setTriggerDay(todayFrom);
                            xxlJobLogReport.setRunningCount(0);
                            xxlJobLogReport.setSucCount(0);
                            xxlJobLogReport.setFailCount(0);

                            //查询失败, 成功，总的调用次数
                            Map<String, Object> triggerCountMap = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findLogReport(todayFrom, todayTo);
                            if(triggerCountMap != null && triggerCountMap.size() > 0){
                                int triggerDayCount = triggerCountMap.containsKey("triggerDayCount")?Integer.valueOf(String.valueOf(triggerCountMap.get("triggerDayCount"))):0;
                                int triggerDayCountRunning = triggerCountMap.containsKey("triggerDayCountRunning")?Integer.valueOf(String.valueOf(triggerCountMap.get("triggerDayCountRunning"))):0;
                                int triggerDayCountSuc = triggerCountMap.containsKey("triggerDayCountSuc")?Integer.valueOf(String.valueOf(triggerCountMap.get("triggerDayCountSuc"))):0;
                                int triggerDayCountFail = triggerDayCount - triggerDayCountRunning - triggerDayCountSuc;

                                xxlJobLogReport.setRunningCount(triggerDayCountRunning);
                                xxlJobLogReport.setSucCount(triggerDayCountSuc);
                                xxlJobLogReport.setFailCount(triggerDayCountFail);
                            }

                            //刷新
                            //刷新调用次数，若找不到则默认都是0
                            int ret = XxlJobAdminConfig.getAdminConfig().getXxlJobLogReportDao().update(xxlJobLogReport);
                            if(ret < 1){
                                //没数据则保存
                                XxlJobAdminConfig.getAdminConfig().getXxlJobLogReportDao().save(xxlJobLogReport);
                            }
                        }
                    }catch (Exception e){
                        if (!toStop) {
                            logger.error(">>>>>>>>>>> xxl-job, job log report thread error:{}", e);
                        }
                    }

                    //log-clean: switch open & once each day
                    //设置了保留日志天数且日志保留了24小时，则进入
                    if (XxlJobAdminConfig.getAdminConfig().getLogretentiondays()>0
                            && System.currentTimeMillis() - lastCleanLogTime > 24*60*60*1000) {

                        //过期时间
                        //通过日志保留天数算出清除log时间
                        Calendar expiredDay = Calendar.getInstance();
                        expiredDay.add(Calendar.DAY_OF_MONTH, -1 * XxlJobAdminConfig.getAdminConfig().getLogretentiondays());
                        expiredDay.set(Calendar.HOUR_OF_DAY, 0);
                        expiredDay.set(Calendar.MINUTE, 0);
                        expiredDay.set(Calendar.SECOND, 0);
                        expiredDay.set(Calendar.MILLISECOND, 0);
                        Date clearBeforeTime = expiredDay.getTime();

                        //清除过期日志
                        List<Long> logIds  =null;
                        do{
                            //这里传了3个0表示查询所有,而不是单个任务id
                            logIds = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findClearLogIds(0, 0, clearBeforeTime, 0, 1000);
                            //删除过期数据
                            if(logIds != null && logIds.size() > 0){
                                XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().clearLog(logIds);
                            }
                        }while (logIds != null && logIds.size() > 0);

                        //更新清理时间
                        lastCleanLogTime = System.currentTimeMillis();
                    }

                    try {
                        TimeUnit.MINUTES.sleep(1);
                    }catch (Exception e){
                        if(!toStop){
                            logger.error(e.getMessage(), e);
                        }
                    }
                }
                logger.info(">>>>>>>>>>> xxl-job, job log report thread stop");
            }
        });
        logrThread.setDaemon(true);
        logrThread.setName("xxl-job, admin JobLogReportHelper");
        logrThread.start();
    }
```





### 三、客户端总配置

- 通过继承具体的某个类型的执行器，把执行器的配置信息导入到初始化执行器中去初始化

```java
public void start() throws Exception{

        //初始化日志路径
        XxlJobFileAppender.initLogPath(logPath);

        //初始化激活 管理-客户端
        initAdminBizList(adminAddresses, accessToken);

        //清除过期日志
        JobLogFileCleanThread.getInstance().start(logRetentionDays);

        //初始化触发反馈线程
        TriggerCallbackThread.getInstance().start();

        //初始化嵌入式服务器
        initEmbedServer(address, ip, port, appname, accessToken);

    }
```

##### 1.初始化日志路径

- 创建初始日志保存路径

```java
public static void initLogPath(String logPath){
        //初始化
        if(logPath != null && logPath.trim().length() > 0){
            logBasePath = logPath;
        }

        //创建目录
        File logPathDir = new File(logBasePath);
        if(!logPathDir.exists()){
            logPathDir.mkdirs();
        }
        logBasePath = logPathDir.getPath();

        //创建glue目录
        File glueBaseDir = new File(logPathDir,"gluesource");
        if(!glueBaseDir.exists()){
            glueBaseDir.mkdirs();
        }
        glueSrcPath = glueBaseDir.getPath();
    }
```

##### 2.初始化客户端执行地址信息

- 把地址和用户token加进List集合

```java
private void initAdminBizList(String adminAddresses,String accessToken)throws Exception{
        if(adminAddresses != null && adminAddresses.trim().length() > 0){
            for(String address: adminAddresses.trim().split(",")){
                if(address != null && address.trim().length() > 0){

                    AdminBiz adminBiz = new AdminBizClient(address.trim(), accessToken);

                    if(adminBizList == null){
                        adminBizList = new ArrayList<AdminBiz>();
                    }
                    adminBizList.add(adminBiz);
                }
            }
        }
    }
```

##### 3.清理文件夹的过期日志数据

```java
public void start(final long logRetentionDays){

        //限制日志清理最小时间
        if(logRetentionDays < 3){
            return;
        }

        localThread = new Thread(new Runnable() {
            @Override
            public void run() {
                while (!toStop){
                    try{
                        //清理大于最大保存时间的日志文件
                        File[] childDirs = new File(XxlJobFileAppender.getLogPath()).listFiles();
                        if(childDirs != null && childDirs.length > 0){

                            //今天的时间
                            Calendar todayCal = Calendar.getInstance();
                            todayCal.set(Calendar.HOUR_OF_DAY,0);
                            todayCal.set(Calendar.MINUTE,0);
                            todayCal.set(Calendar.SECOND,0);
                            todayCal.set(Calendar.MILLISECOND,0);

                            Date todayDate = todayCal.getTime();

                            for(File childFile: childDirs){

                                //判断文件是否是一个目录
                                if(!childFile.isDirectory()){
                                    continue;
                                }

                                //判断是否命名规范
                                if(childFile.getName().indexOf("-") == -1){
                                    continue;
                                }

                                //判断文件创建时间
                                Date logFileCreateDate = null;
                                try {
                                    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");
                                    logFileCreateDate = simpleDateFormat.parse(childFile.getName());
                                }catch (Exception e){
                                    logger.error(e.getMessage(),e);
                                }
                                if(logFileCreateDate == null){
                                    continue;
                                }

                                //删除过期文件夹
                                if ((todayDate.getTime()-logFileCreateDate.getTime()) >= logRetentionDays * (24 * 60 * 60 * 1000) ) {
                                    FileUtil.deleteRecursively(childFile);
                                }
                            }
                        }
                    }catch (Exception e){
                        if(!toStop){
                            logger.error(e.getMessage(),e);
                        }
                    }

                    //删除完这天的日志，睡眠一天再删除
                    try {
                        TimeUnit.DAYS.sleep(1);
                    }catch (InterruptedException e){
                        if(!toStop){
                            logger.error(e.getMessage(),e);
                        }
                    }
                }
                logger.info(">>>>>>>>>>> xxl-job, executor JobLogFileCleanThread thread destroy.");
            }
        });
        localThread.setDaemon(true);
        localThread.setName("xxl-job, executor JobLogFileCleanThread");
        localThread.start();
    }
```

##### 4.初始化反馈操作

- 初始化反馈操作，可以对任务列表的信息执行反馈操作，并且对log文件中失败的文件进行反馈操作。

```java
public void start(){

        //判断执行列表是否有东西
        if (XxlJobExecutor.getAdminBizList() == null) {
            logger.warn(">>>>>>>>>>> xxl-job, executor callback config fail, adminAddresses is null.");
            return;
        }

        //反馈
        triggerCallbackThread = new Thread(new Runnable() {

            @Override
            public void run() {

                while (!toStop){
                    try {
                        //从反馈队列调取一个参数
                        HandleCallbackParam callback = getInstance().callBackQueue.take();
                        if(callback != null){

                            //回调执行参数集合
                            List<HandleCallbackParam> callbackParamList = new ArrayList<HandleCallbackParam>();
                            //将队列所有参数都放在集合中
                            int drainToNum = getInstance().callBackQueue.drainTo(callbackParamList);
                            callbackParamList.add(callback);

                            //反馈信息
                            if(callbackParamList != null && callbackParamList.size() > 0){
                                doCallback(callbackParamList);
                            }
                        }
                    }catch (Exception e){
                        if(!toStop){
                            logger.error(e.getMessage(),e);
                        }
                    }
                }

                //获取剩余元素并再次执行反馈
                try {
                    //反馈执行参数集合
                    List<HandleCallbackParam> callbackParamList = new ArrayList<HandleCallbackParam>();
                    //将队列所有参数都放在集合中
                    int drainToNum = getInstance().callBackQueue.drainTo(callbackParamList);
                    //反馈，错误重试
                    if(callbackParamList != null && callbackParamList.size() > 0){
                        doCallback(callbackParamList);
                    }
                }catch (Exception e){
                    if(!toStop){
                        logger.error(e.getMessage(),e);
                    }
                }
                logger.info(">>>>>>>>>>> xxl-job, executor callback thread destroy.");
            }
        });
        triggerCallbackThread.setDaemon(true);
        triggerCallbackThread.setName("xxl-job, executor TriggerCallbackThread");
        triggerCallbackThread.start();

        //重试
        triggerRetryCallbackThread = new Thread(new Runnable() {

            @Override
            public void run() {
                while (!toStop){
                    try {
                        retryFailCallbackFile();
                    }catch (Exception e){
                        if(!toStop){
                            logger.error(e.getMessage(), e);
                        }
                    }

                    try {
                        TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT);
                    }catch (InterruptedException e) {
                         if(!toStop){
                             logger.error(e.getMessage(),e);
                         }
                    }
                }
                logger.info(">>>>>>>>>>> xxl-job, executor retry callback thread destroy.");
            }
        });
        triggerRetryCallbackThread.setDaemon(true);
        triggerRetryCallbackThread.start();
    }
```

- 之后的函数是给log文件或者反馈文件加具体信息.......

##### 5.初始化嵌入式服务器

- 嵌入式服务器绑定端口号成为执行器

```java
private void initEmbedServer(String address, String ip, int port, String appname, String accessToken) throws Exception {

        //找到端口号
        port = port>0?port: NetUtil.findAvailablePort(9999);
        ip = (ip != null && ip.trim().length() >0)?ip: IpUtil.getIp();

        //生成地址
        if(address == null || address.trim().length() == 0){
            String ip_port_address = IpUtil.getIpPort(ip, port);
            address = "http://{ip_port}/".replace("{ip_port}", ip_port_address);
        }

        //许可Token
        if(accessToken == null || accessToken.trim().length() == 0){
            logger.warn(">>>>>>>>>>> xxl-job accessToken is empty. To ensure system security, please set the accessToken.");
        }

        //开启嵌入式服务器
        embedServer = new EmbedServer();
        embedServer.start(address, port, appname, accessToken);
    }
```

- 开启netty服务线程

```java
 public void start(final String address, final int port, final String appname, final String accessToken) {
        executorBiz = new ExecutorBizImpl();

        thread = new Thread(new Runnable() {

            @Override
            public void run() {
                // Netty 中的事件循环组，用于处理网络事件
                //用于接受客户端连接
                EventLoopGroup bossGroup = new NioEventLoopGroup();
                //用于处理连接后的数据交换
                EventLoopGroup workerGroup = new NioEventLoopGroup();
                ThreadPoolExecutor bizThreadPool = new ThreadPoolExecutor(
                        0,
                        200,
                        60L,
                        TimeUnit.SECONDS,
                        new LinkedBlockingQueue<Runnable>(2000),
                        new ThreadFactory() {   //线程工厂，用于创建新线程
                            @Override
                            public Thread newThread(Runnable r) {
                                return new Thread(r, "xxl-job, EmbedServer bizThreadPool-" + r.hashCode());
                            }
                        },
                        new RejectedExecutionHandler() {
                            @Override
                            //拒绝策略
                            public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
                                throw new RuntimeException("xxl-job, EmbedServer bizThreadPool is EXHAUSTED!");
                            }
                        });
                try {
                    ServerBootstrap bootstrap = new ServerBootstrap();
                    bootstrap.group(bossGroup, workerGroup)
                            .channel(NioServerSocketChannel.class)
                            .childHandler(new ChannelInitializer<SocketChannel>() {
                                @Override
                                public void initChannel(SocketChannel channel) throws Exception {
                                    channel.pipeline()
                                            .addLast(new IdleStateHandler(0, 0, 30 * 3, TimeUnit.SECONDS))  // beat 3N, close if idle
                                            .addLast(new HttpServerCodec())
                                            .addLast(new HttpObjectAggregator(5 * 1024 * 1024))  // merge request & reponse to FULL
                                            .addLast(new EmbedHttpServerHandler(executorBiz, accessToken, bizThreadPool));
                                }
                            })
                            .childOption(ChannelOption.SO_KEEPALIVE, true);

                    // 绑定端口
                    ChannelFuture future = bootstrap.bind(port).sync();

                    logger.info(">>>>>>>>>>> xxl-job remoting server start success, nettype = {}, port = {}", EmbedServer.class, port);

                    // 启动注册中心
                    startRegistry(appname, address);

                    // 等待服务端关闭
                    future.channel().closeFuture().sync();
                }catch (InterruptedException e) {
                    logger.info(">>>>>>>>>>> xxl-job remoting server stop.");
                } catch (Exception e) {
                    logger.error(">>>>>>>>>>> xxl-job remoting server error.", e);
                } finally {
                    // 停止服务
                    try {
                        workerGroup.shutdownGracefully();
                        bossGroup.shutdownGracefully();
                    } catch (Exception e) {
                        logger.error(e.getMessage(), e);
                    }
                }
            }
        });
        thread.setDaemon(true);
        thread.start();
    }
```











